# Prefix AST
  In implementarea am folosit 2 apeluri de functii, 'preordine' si 'evaluare_expresie'. 
  
  Prima functie, 'preordine' este o functie recursiva in cadrul careia am parcurs arborele si am convertit operanzii de la string la intregi, memorandu-i alaturi de operatori in vectorul 'array'. Pentru a parcurge recursiv arborele am dereferentiat radacina (data ca 'adresa la adresa radacinii'), mergand recursiv catre subarborii stang si drept pe baza offset-ului fata de radacina dat de constructia structurii arborelui (4 pentru subarborele stang si 8 penru subarborele drept). Pentru a putea evalua ca intregi operatorii am convertit fiecare caracter din string la intreg (operatiile aferente marcate cu label-ul 'atoi). Stocand succesiv caracterele in ebx, am verificat daca caracterul curent nu este terminator de sir (0x00), apoi daca este operand sau operator; in acest scop am definti functia 'check_if_operator' pentru care am considerat ca argument caracterul curent am stringului evaluat. In cadrul functiei 'check_if_operator' caracterul este comparat cu cele 4 caractere care simbolizeaza operatori; rezultatul este pasat prin registrul edx: daca edx contine valoarea 1, caracterul este operand, altfel, daca edx contine valoarea 0, caracterul este operator.
  
  Revenind din functie, am tratat special cazul caracterul '-' pentru ca acesta poate avea dubla interpretare: operator - sau parte a reprezentarii unui numar negativ; pentru verificare am dereferentiat eax (mov eax, [eax]) -> daca caracterul curent este operator, va exista identitate intre eax si '-', in caz contrar putand sa deducem ca caracterul '-' marcheaza un numar negativ. 
  
  Pentru situatia numerelor negative am folosit registul edi, memorand in acesta valoarea 255, atunci cand se face evaluarea unui numar negativ. Astfel, dupa ce am parcurs toate cifrele am verificat continutul registrului edi: in cazul numerelor negative am folosit intructiunea 'neg' pentru a nega rezultatul obtinut (practic valoarea in modul a numarului). De fiecare data am memorat in 'array' numarul obtinut precum si operatorii (in ordinea in care au fost preluate din arbore).
  
  In cadrul functiei 'evaluare_expresie' am parcurs vectorul de la dreapta la stanga si am folosit stiva pentru a evalua rezulatul expresiei. Astfel, fiecare operand identificat este pus de stiva iar la intalnirea unui operator se scot de pe stiva 2 operanzi, se efectueaza operatia indicata de operatorul curent si se pune pe stiva rezultatul. La finalul parcurgerii vectorului, rezulatul final se va afla pe stiva. De asemenea, am folosit si aici functia 'check_if_operator' pentru a evalua elementul curent preluat din 'array'. Pentru operatiile elementare am folosit instructiunile add, sub, idiv si imul, in cadrul impartirii facand si extensie a bitului de semn din eax in edx (cdq).


